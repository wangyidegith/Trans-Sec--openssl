密码学基础（1 计算上不可破，而不是理论上不可破 2 密码编码学和密码分析学组成密码学）
（一） 机密性
1 对称加密：DES（这个已经不太行了）、3DES（也不太行了）、AES（128、192、256位密钥，AES256是我们最常用的，密钥越长越安全但效率也越低）。
（1） 特点：算法公开、密钥保密。
（2） 加密过程：通信双方使用同一密钥进行加解密。
（3） 密钥（Secret Key）的生成：一般由密码（一个字符串，这是需要绝对保密的，不可在网络上传输）生成，且该过程不可逆。
（4） 加盐（解决一致性问题）：同一密钥、同一明文，生成的密文肯定是一致的，因而这里可能会被彩虹表攻击，可以加盐，加的盐如果短的话也不行（WEP协议的漏洞），会容易被破解。

2 非对称加密：RSA。
（1） 产生原因：一是对称密钥不好分配，比如要更换密钥，如何传输这个密钥，不能网络传，用信件又很慢，KDC虽然安全但是耗费网络资源，二是对数字签名的需要。
（2） 特点：算法公开、私钥保密、公钥公开。
（3） 加密算法：A向B发送数据，则A使用B的公钥加密数据（因而在连接初期（第一次或者第二次握手），B就给把自己的公钥发给A），发给B后B使用自己的私钥解密数据。
（4） 密钥的生成（区块链的核心基础）：字符串（区块链叫助记词，也就是密码，ssh-keygen的时候密码也能不写）->私钥->公钥->账号（区块链生成的是地址）。
（5） 公私钥与对称密钥的不同：
a 对称密钥加密也由它解密，但公钥和私钥可以加密明文，却不能解密。公钥加密了，只能由私钥解密，反之，私钥加密了，只能由公钥解密。
b 不同于对称密钥只能用于一对一通信，公私钥可以用于多对一通信。
（6）公钥算法的缺点：虽然看上去公私钥要比对称密钥更好，但是公私钥的开销较大，因而在机密性这个点上公私钥更多时候用于加密对称密钥，然后使用对称密钥进行通信。
（7）私钥一旦泄露意味着机密性丢失，因而一般认为私钥不可在网络上传输，就算cat也不要cat它。
（8）安全问题：如果公钥可信，那么之后，公钥加密是可以的，但是公钥是需要进行交换的，如果在交换中发生中间人攻击导致公钥本身就不可信呢？因而这也是证书的产生原因。



（二） 数字签名：在通信安全上的可提供实体鉴别（鉴别（很多时候也叫鉴权或验签）分为实体鉴别或端点鉴别和报文鉴别，实体鉴别只鉴别一次，报文鉴别包括实体鉴别和完整性）、完整性、不可否认性，但是事实上由于数字签名的开销较大，很多时候并不使用其做完整性，而是仅在通信伊始提供实体鉴别和不可否认性。
0 背景
（0）数字签名的背景：A向B发送数据，那么B怎么知道这是A在向我发包而不是什么黑客在向我发包呢？B又怎么知道A发的数据没有被黑客篡改呢？如果A后续否认了这个发包，B又怎么反击A呢？
（1）认证技术
a 对一般认证的认识
从日常来看：注册 + 登录 + 注销 + 找回密码，这一整套都是认证技术。
认证的元素：账户 = 账号（用户名） + 密码
账号的特性：唯一性。多为手机号，有的系统会要求用户自定义用户名。
密码的特性：不可见性。密码的本质在于为了证明某个实体拥有访问某个实体的权限，所以这一点决定了密码的不可见性。
现在的应用场景：使用手机验证码作为密码登录的情况是最多见的。
安全问题：登录从最根本上说是一次TCP连接，而TCP连接无法被限制，这导致暴力破解具备可行性。
b 用于维持登录状态的认证（会话管理）
cookie的思路：用户携带着服务器分配给用户的仅有用户自己知道的信息到服务器，服务器会在数据库里面查有没有这个信息，有那就说明登录了，没有就让用户去用用户名和密码登录。
c 数字签名是一种特殊的认证技术
验签的原理就是私钥只可能被一个实体知晓，所以只要用这个实体的公钥解密成功那么就说明确实是这个实体。（这就是为什么JWT是不需要存储任何状态的）
ssh私钥登录就是经典例子，在ssh命令文章中有具体的操作步骤。
数字签名使得暴力破解不具备可行性。
但是由于客户端证书的不普及所以这种基于数字签名的登录还不是很普及，因而弱口令漏洞还是严重的安全威胁。
使用数字签名的会话管理技术（JWT，思路很清奇）：
JWT的思路：用户携带着服务器分配给用户的仅有用户自己知道的信息（这个信息是被服务器私钥签过名的）到服务器，服务器用自己的私钥解密，因为只有服务器自己能解密所以服务器就会认为这个客户端已经登录过了要不就是解密不可能成功。

1 真实性
（0）验签的过程：A在发送数据时使用A的私钥进行加密，生成一个值作为数字签名，将签名和明文一起发送到B后，B使用A的公钥对密文解密（因而在握手初期B必须拿到A的公钥），发现原明文和通过公钥解密得到的明文一致则说明这确实是A发的。
（1）原理：因为这个世界上只有A有A的私钥，只有A能生成用其公钥解密后能够和原明文比对成功的密文，如果有黑客C想伪造自己是A，他没有A的私钥，他只能用自己的私钥加密，此时B用A的公钥解密一个用C的私钥加密的密文，结果必然和原明文不一致。
（2）安全问题：如果公钥可信，那么之后，数字签名可以保证鉴别的正确性，但是公钥是需要进行交换的，如果在交换中发生中间人攻击导致公钥本身就不可信呢？因而这也是证书的产生原因。

2 完整性：B在使用A的公钥解密后得到与原明文一致的明文则说明报文未被篡改，因为如果黑客改了他没有A的私钥就生不成可以成功骗过B的密文；

3 不可否认性：如果将来A否认自己向B发过这个包，那么B可以把这个包（明文+密文）发给任何其他人，其他人都是知道A的公钥的，对密文解密发现与原明文一致，因而大家便会认定这是A发的。



（三） 完整性（数字指纹、数字摘要，总之就是digest）
1 数字签名在保障完整性方面开销较大，因而产生了数字指纹或者说摘要这种简易方法。

2 数学家发明了一种函数，叫密码散列函数（哈希算法），其中散列，英文名hash（这便是哈希的由来）。辨析：哈希是一种算法（由一个值算成另一个值），哈希值是得到的值，哈希值也叫指纹、摘要（digest）。

3 密码散列函数有如下特点：
（1） 是单向函数即正着算容易算但反着算不可能；
（2） 可以得到固定长度的输出；
（3） 不同明文可能得到同一摘要，这又称为哈希碰撞，但是好的哈希算法是可以避免这种情况的，比如sha256。

4 目前主流的哈希算法有：
（1）MD5（Message Digest 5）：128位（16B），表示为32字节；
注：位数除以8是字节数，这是实际存储的字节数，但是我一般使用十六进制表示，因而MD5的十六进制表示32B。
（2）SHA（Secure Hash Algorithm）系列：
SHA-1: 160位，表示为40B
SHA-224: 224位
SHA-256: 256位，表示为64B
SHA-384: 384位
SHA-512: 512位
最广泛使用的哈希算法便是sha256，大名鼎鼎的比特币便使用该算法。

5 哈希算法如何确保报文完整性？
A向B发送报文，sha256（明文）得到哈希值作为报文鉴别码，放在明文中一起加密并传输，B收到后解密，再计算sha256（明文）则得到哈希值，和报文鉴别码比对，一致则完整没被篡改，不一致则被改了。
那么如果黑客截获，改掉了明文并使sha256（改掉的明文）得到一个新的哈希值作为报文鉴别码呢？事实上黑客是不可能在加密的数据中正好做到这一点的，因而完整性正是为了防止黑客“偷鸡不成蚀把米”，看不到数据就瞎改，他只要改，哈希值就对不上。

